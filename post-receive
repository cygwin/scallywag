#!/usr/bin/env python3
#
# post-receive hook to start a package build via appveyor REST API
#

import json
import os
import sqlite3
import subprocess
import sys
import time
import urllib.error
import urllib.request

import carpetbag
import gh_token

account = subprocess.check_output(['git', 'config', 'appveyor.account']).strip().decode('ascii')
token = subprocess.check_output(['git', 'config', 'appveyor.token']).strip().decode('ascii')
slug = 'scallywag'


def _appveyor_build_request(package, maintainer, commit, reference, default_tokens, buildnumber):
    data = {
        "accountName": account,
        "projectSlug": slug,
        "branch": "master",
        "environmentVariables": {
            "BUILDNUMBER": buildnumber,
            "PACKAGE": package,
            "MAINTAINER": maintainer,
            "COMMIT": commit,
            "REFERENCE": reference,
            "DEFAULT_TOKENS": default_tokens,
        }
    }

    req = urllib.request.Request('https://ci.appveyor.com/api/builds')

    req.add_header('Content-Type', 'application/json')
    req.add_header('Accept', 'application/json')
    req.add_header('Authorization', 'Bearer ' + token)

    try:
        response = urllib.request.urlopen(req, json.dumps(data).encode('utf-8'))
    except urllib.error.URLError as e:
        response = e

    status = response.getcode()
    if status != 200:
        print('scallywag: AppVeyor REST API failed status %s' % (status))
        return False

    return True


def _github_workflow_trigger(package, maintainer, commit, reference, default_tokens, buildnumber):
    data = {
        "event_type": "(%s) %s" % (buildnumber, package),  # use this just because it appears as the run name in UI
        "client_payload": {
            "BUILDNUMBER": buildnumber,
            "PACKAGE": package,
            "MAINTAINER": maintainer,
            "COMMIT": commit,
            "REFERENCE": reference,
            "DEFAULT_TOKENS": default_tokens,
        }
    }

    req = urllib.request.Request('https://api.github.com/repos/cygwin/scallywag/dispatches')

    req.add_header('Accept', 'application/vnd.github.v3+json')
    req.add_header('Authorization', 'Bearer ' + gh_token.fetch_iat())

    try:
        response = urllib.request.urlopen(req, data=json.dumps(data).encode('utf-8'))
    except urllib.error.URLError as e:
        response = e

    status = response.getcode()
    if status != 204:
        print('scallywag: GitHub REST API failed status %s' % (status))
        return False

    return True

def post_receive(commit, reference):
    repo = os.environ['GL_REPO']  # set by gitolite
    maintainer = os.environ['CYGNAME']  # set for ssh-wrapper

    default_tokens = ''
    try:
        with open(os.path.join('/sourceware/cygwin-staging/home', maintainer, '!scallywag')) as f:
            default_tokens = ''.join([l.strip() for l in f.readlines()])
    except FileNotFoundError:
        pass

    if 'disable' in default_tokens:
        print('scallywag: disabled by you')
        return

    _, package = os.path.split(repo)
    if package.endswith('.git'):
        package, _ = os.path.splitext(package)

    # record job as requested and generate buildnumber
    with sqlite3.connect(carpetbag.dbfile) as conn:
        cursor = conn.execute('INSERT INTO jobs (srcpkg, hash, ref, user, status) VALUES (?, ?, ?, ?, ?)',
                     (package, commit, reference, maintainer, 'requested'))
        buildnumber = cursor.lastrowid
        conn.commit()

    status = _github_workflow_trigger(package, maintainer, commit, reference, default_tokens, buildnumber)

    backend = 'appveyor'
    status = _appveyor_build_request(package, maintainer, commit, reference, default_tokens, buildnumber)

    if not status:
        return

    print('scallywag: build {0} queued on {1}'.format(buildnumber, backend))
    print('scallywag: https://cygwin.com/cgi-bin2/jobs.cgi?id={0}'.format(buildnumber))

    # record job as pending
    now = time.time()
    with sqlite3.connect(carpetbag.dbfile) as conn:
        conn.execute('UPDATE jobs SET status = ?, start_timestamp = ?, end_timestamp = ?, backend = ? WHERE id = ?',
                     ('pending', now, now, backend, buildnumber))
        conn.commit()


if __name__ == '__main__':
    for line in sys.stdin.readlines():
        old, new, ref = line.strip().split()
        if ref.startswith('refs/heads/') and new != '0000000000000000000000000000000000000000':
            # only do something if a branch ref is updated
            post_receive(new, ref)
