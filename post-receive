#!/usr/bin/env python3
#
# post-receive hook to start a package build via appveyor REST API
#

import json
import os
import sqlite3
import subprocess
import sys
import time
import urllib.error
import urllib.request

import carpetbag
import gh_token

account = subprocess.check_output(['git', 'config', 'appveyor.account']).strip().decode('ascii')
token = subprocess.check_output(['git', 'config', 'appveyor.token']).strip().decode('ascii')
slug = 'scallywag'


def _appveyor_build_request(package, maintainer, commit, reference, default_tokens, buildnumber):
    data = {
        "accountName": account,
        "projectSlug": slug,
        "branch": "master",
        "environmentVariables": {
            "BUILDNUMBER": buildnumber,
            "PACKAGE": package,
            "MAINTAINER": maintainer,
            "COMMIT": commit,
            "REFERENCE": reference,
            "DEFAULT_TOKENS": default_tokens,
        }
    }

    req = urllib.request.Request('https://ci.appveyor.com/api/builds')

    req.add_header('Content-Type', 'application/json')
    req.add_header('Accept', 'application/json')
    req.add_header('Authorization', 'Bearer ' + token)

    try:
        response = urllib.request.urlopen(req, json.dumps(data).encode('utf-8'))
    except urllib.error.URLError as e:
        response = e

    status = response.getcode()
    if status != 200:
        print('scallywag: AppVeyor REST API failed status %s' % (status))
        return -1

    j = json.loads(response.read().decode('utf-8'))
    return j['buildId']


def _github_most_recent_wfr_id():
    data = {
        "event": "repository_dispatch",
        "per_page": 1
        }

    qs = urllib.parse.urlencode(data)

    req = urllib.request.Request('https://api.github.com/repos/cygwin/scallywag/actions/runs' + '?' + qs)
    req.add_header('Accept', 'application/vnd.github.v3+json')
    req.add_header('Authorization', 'Bearer ' + gh_token.fetch_iat())

    try:
        response = urllib.request.urlopen(req)
    except urllib.error.URLError as e:
        response = e

    status = response.getcode()
    if status != 200:
        print('scallywag: GitHub REST API failed status %s' % (status))
        return 0, None

    j = json.loads(response.read().decode('utf-8'))

    wfr = j['workflow_runs']
    if len(wfr) <= 0:
        return 0, None

    return wfr[0]['id'], wfr[0]['html_url']


def _github_workflow_trigger(package, maintainer, commit, reference, default_tokens, buildnumber):
    prev_wrf_id, _ = _github_most_recent_wfr_id()

    data = {
        "event_type": "(%s) %s" % (buildnumber, package),  # use this just because it appears as the run name in UI
        "client_payload": {
            "BUILDNUMBER": buildnumber,
            "PACKAGE": package,
            "MAINTAINER": maintainer,
            "COMMIT": commit,
            "REFERENCE": reference,
            "DEFAULT_TOKENS": default_tokens,
        }
    }

    req = urllib.request.Request('https://api.github.com/repos/cygwin/scallywag/dispatches')

    req.add_header('Accept', 'application/vnd.github.v3+json')
    req.add_header('Authorization', 'Bearer ' + gh_token.fetch_iat())

    try:
        response = urllib.request.urlopen(req, data=json.dumps(data).encode('utf-8'))
    except urllib.error.URLError as e:
        response = e

    status = response.getcode()
    if status != 204:
        print('scallywag: GitHub REST API failed status %s' % (status))
        return -1, None

    # response has no content, and doesn't give an id for the workflow that
    # we've just requested. all we can do is poll the workflow runs list and
    # guess that the most recent one is ours.
    #
    # (it seems that it takes a little while for the requested run to appear in
    # the workflow run list, with status 'queued', and then some time later it
    # changes to status 'in_progress'.)
    #
    # and since there may exist other runs with status 'in_progress', the only
    # half-way reliable way to do this is to poll until a new wfr id appears...
    #
    # see https://github.community/t/repository-dispatch-response/17950

    for i in range(1, 10):
        wfr_id, buildurl = _github_most_recent_wfr_id()

        if wfr_id != prev_wrf_id:
            return wfr_id, buildurl

        time.sleep(1)

    return 0, None


def post_receive(commit, reference):
    repo = os.environ['GL_REPO']  # set by gitolite
    maintainer = os.environ['CYGNAME']  # set for ssh-wrapper

    default_tokens = ''
    try:
        with open(os.path.join('/sourceware/cygwin-staging/home', maintainer, '!scallywag')) as f:
            default_tokens = ''.join([l.strip() for l in f.readlines()])
    except FileNotFoundError:
        pass

    for i in range(0, int(os.environ.get('GIT_PUSH_OPTION_COUNT', '0'))):
        print('%s: %s' % ('GIT_PUSH_OPTION_%s' % i, os.environ['GIT_PUSH_OPTION_%s' % i]))
        default_tokens += ' ' + os.environ['GIT_PUSH_OPTION_%s' % i].strip()

    if 'disable' in default_tokens:
        print('scallywag: disabled by you')
        return

    _, package = os.path.split(repo)
    if package.endswith('.git'):
        package, _ = os.path.splitext(package)

    # record job as requested and generate buildnumber
    with sqlite3.connect(carpetbag.dbfile) as conn:
        cursor = conn.execute('INSERT INTO jobs (srcpkg, hash, ref, user, status) VALUES (?, ?, ?, ?, ?)',
                     (package, commit, reference, maintainer, 'requested'))
        buildnumber = cursor.lastrowid
        conn.commit()

    # request job
    if 'appveyor' in default_tokens:
        backend = 'appveyor'
        bbid = _appveyor_build_request(package, maintainer, commit, reference, default_tokens, buildnumber)
        buildurl = None
    else:
        backend = 'github'
        bbid, buildurl = _github_workflow_trigger(package, maintainer, commit, reference, default_tokens, buildnumber)

    if bbid < 0:
        return

    print('scallywag: build {0} queued on {1}'.format(buildnumber, backend))
    print('scallywag: https://cygwin.com/cgi-bin2/jobs.cgi?id={0}'.format(buildnumber))

    # record job as pending
    now = time.time()
    with sqlite3.connect(carpetbag.dbfile) as conn:
        conn.execute('UPDATE jobs SET status = ?, logurl = ?, start_timestamp = ?, end_timestamp = ?, backend = ?, backend_id = ? WHERE id = ?',
                     ('pending', buildurl, now, now, backend, bbid, buildnumber))
        conn.commit()


if __name__ == '__main__':
    for line in sys.stdin.readlines():
        old, new, ref = line.strip().split()
        if ref.startswith('refs/heads/') and new != '0000000000000000000000000000000000000000':
            # only do something if a branch ref is updated
            post_receive(new, ref)
