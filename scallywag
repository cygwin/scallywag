#!/usr/bin/env python3

import argparse
import glob
import json
import logging
import os
import shutil
import subprocess
import sys
import urllib.error
import urllib.request

from analyze import analyze

logging.getLogger().setLevel(logging.INFO)
logging.basicConfig(format=os.path.basename(sys.argv[0]) + ': %(message)s')

parser = argparse.ArgumentParser(description='scallywag')
parser.add_argument('--inputs', dest='inputs', action='store', help='JSON encoded input parameters')
args = parser.parse_args()

if args.inputs:
    args_dict = json.loads(args.inputs)
else:
    args_dict = os.environ

buildnumber = args_dict['BUILDNUMBER']
name = args_dict['PACKAGE']
maintainer = args_dict['MAINTAINER']
commit = args_dict['COMMIT']
reference = args_dict['REFERENCE']
default_tokens = args_dict.get('DEFAULT_TOKENS', '')

logging.info('package is %s' % (name))

# make a directory for working with the package repo
mydir = os.getcwd()
os.chdir(os.path.join(mydir, '..'))
os.mkdir(name)
os.chdir(name)

# clone the package repo
# 'git clone' can't do a shallow clone of a specific commit.
#
# (This requires allowReachableSHA1InWant to be true at the remote, to allow
# non-branch/tag tip commits to be fetched)
try:
    subprocess.check_call(['git', 'config', '--global', 'init.defaultBranch', 'master'])
    subprocess.check_call(['git', 'init'])
    subprocess.check_call(['git', 'remote', 'add', 'origin', 'git://cygwin.com/git/cygwin-packages/%s.git' % (name)])
    subprocess.check_call(['git', 'fetch', '--depth=1', 'origin', commit])
    subprocess.check_call(['git', 'checkout', '-B', 'master', 'FETCH_HEAD'])
    subprocess.check_call(['git', 'submodule', 'update', '--init', '--recursive'])
    # Using '--depth=1' with a submodule will fail if the remote doesn't have
    # allowReachableSHA1InWant set.  If it does, the submodule should be
    # configured as shallow in .gitmodules, so '--recommend-shallow' turns that
    # on.
except (subprocess.CalledProcessError, FileNotFoundError):
    logging.info('something went wrong cloning the package repo')
    sys.exit(1)

# analyze the repo
package = analyze(os.getcwd(), default_tokens.split())

# compare target arch(es) and build environment
arch = os.environ['BUILD'].split('-')[0]
logging.info('build ARCH: %s, cygport ARCHes: %s' % (arch, package.arches))

if ('noarch' in package.arches) and ('APPVEYOR' in os.environ):
    # noarch packages get built using x86_64 environment on AppVeyor
    if arch == 'x86_64':
        arch = 'noarch'
    else:
        arch = 'skip'
elif package.arches:
    # otherwise, build if it builds on this environment
    if arch not in package.arches + ['source']:
        arch = 'skip'

data_items = {
    'BUILDNUMBER': buildnumber,
    'PACKAGE': name,
    'COMMIT': commit,
    'ARCH': arch,
    'MAINTAINER': maintainer,
    'REFERENCE': reference,
    'TOKENS': (' '.join(package.tokens)),
}

if 'APPVEYOR' in os.environ:
    # record package details using build worker API (so they appear in build notification)
    data = {"message": '; '.join('%s: %s' % (k, v) for k, v in data_items.items())}
    req = urllib.request.Request(os.environ['APPVEYOR_API_URL'] + 'api/build/messages')
    req.add_header('Content-Type', 'application/json')
    response = urllib.request.urlopen(req, json.dumps(data).encode('utf-8'))
elif 'GITHUB_JOB' in os.environ:
    # record package details in .json file
    with open(os.path.join(mydir, 'scallywag.json'), 'w') as f:
        print(json.dumps(data_items, sort_keys=True, indent=4), file=f)

if arch == 'skip':
    logging.info('nothing to build on this arch')
    sys.exit(0)

if 'nobuild' in package.tokens:
    logging.info('not building due to nobuild')
    sys.exit(0)

setup_exe = subprocess.check_output(['cygpath', os.environ['SETUP']]).strip()

if package.kind == 'cygport':
    logging.info('installing build dependencies')

    setup_opts = []
    if 'testpackages' in package.tokens:
        setup_opts.append('-t')

    subprocess.check_call([setup_exe,
                           '-q', '-n', '-O', '-g'] + setup_opts + [
                           '-R', os.environ['CYGWIN_ROOT'],
                           '-s', os.environ['CYGWIN_MIRROR'],
                           '-l', os.environ['CACHE'],
                           '-P', ','.join(package.depends)])

    # preserve setup.log.full
    shutil.move('/var/log/setup.log.full', os.path.join(mydir, 'setup.log.full'))

    # fetch upstream sources and do the build
    subcommands = ['download']
    if arch != 'source':
        if 'label' in package.tokens:
            subcommands.append('all-test')
        else:
            subcommands.append('all')
        if 'notest' not in package.tokens:
            subcommands.append('test')
    else:
        subcommands.append('srcpackage')
    logging.info("running 'cygport %s'" % (' '.join(subcommands)))
    rc = subprocess.call([os.path.join(mydir, 'build.sh'), package.script] +
                         subcommands, stdin=subprocess.DEVNULL)

    # publish contents of dist as artifacts
    dist = glob.glob(os.path.join('*', 'dist'))
    if dist:
        logging.info('publishing artifacts')
        stagingdir = os.path.join(mydir, 'staging')
        shutil.move(dist[0], stagingdir)
        for (dirpath, _, files) in os.walk(stagingdir):
            for f in files:
                logging.info(os.path.relpath(os.path.join(dirpath, f), mydir))

    # publish an archive with contents of builddir
    subprocess.check_call('tar -Jcf %s *' % (os.path.join(mydir, 'builddir.tar.xz')),
                          shell=True)

    sys.exit(rc)
else:
    logging.info("don't know how to build this package")
    sys.exit(1)
