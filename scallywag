#!/usr/bin/env python3

import glob
import json
import logging
import os
import shutil
import subprocess
import sys
import urllib.error
import urllib.request

from analyze import analyze

logging.getLogger().setLevel(logging.INFO)
logging.basicConfig(format=os.path.basename(sys.argv[0]) + ': %(message)s')

name = os.environ['PACKAGE']
logging.info('package is %s' % (name))

maintainer = os.environ['MAINTAINER']
commit = os.environ['COMMIT']

# make a directory for working with the package repo
mydir = os.environ['APPVEYOR_BUILD_FOLDER']
os.chdir(os.path.join(mydir, '..'))
os.mkdir(name)
os.chdir(name)

# clone the package repo
# 'git clone' can't do a shallow clone of a specific commit.
#
# (This requires allowReachableSHA1InWant to be true at the remote, to allow
# non-branch/tag tip commits to be fetched)
subprocess.check_call(['git', 'init'])
subprocess.check_call(['git', 'remote', 'add', 'origin', 'git://cygwin.com/git/cygwin-packages/%s.git' % (name)])
subprocess.check_call(['git', 'fetch', '--depth=1', 'origin', commit])
subprocess.check_call(['git', 'checkout', '-b', 'work', 'FETCH_HEAD'])

# analyze the repo
package = analyze(os.getcwd())

# compare target arch(es) and build environment
arch = os.environ['BUILD'].split('-')[0]
logging.info('build ARCH: %s, cygport ARCHes: %s' % (arch, package.arches))
if 'noarch' in package.arches:
    # noarch packages get built using x86_64 environment
    if arch == 'x86_64':
        arch = 'noarch'
    else:
        arch = 'skip'
else:
    # otherwise, build if it builds on this environment
    if arch not in package.arches:
        arch = 'skip'

# record package details using build worker API (so they appear in build notification)
data = {
    "message": 'PACKAGE: %s; COMMIT: %s; ARCH: %s; MAINTAINER: %s' % (name, commit, arch, maintainer),
}

req = urllib.request.Request(os.environ['APPVEYOR_API_URL'] + 'api/build/messages')
req.add_header('Content-Type', 'application/json')
response = urllib.request.urlopen(req, json.dumps(data).encode('utf-8'))

if arch == 'skip':
    logging.info('nothing to build on this arch')
    sys.exit(0)

if package.kind == 'cygport':
    # install the build dependencies
    logging.info('installing build dependencies')
    subprocess.check_call([os.path.join('/', os.environ['SETUP'].strip()),
                           '-q', '-n', '-O',
                           '-R', os.environ['CYGWIN_ROOT'],
                           '-s', os.environ['CYGWIN_MIRROR'],
                           '-l', os.environ['CACHE'],
                           '-P', ','.join(package.depends)])

    # work-around setup's limited handling of obsolete packages by running it
    # again to upgrade any obsolete packages which just got installed
    logging.info('updating build dependencies')
    subprocess.check_call([os.path.join('/', os.environ['SETUP'].strip()),
                           '-q', '-n', '-O', '-g',
                           '-R', os.environ['CYGWIN_ROOT'],
                           '-s', os.environ['CYGWIN_MIRROR'],
                           '-l', os.environ['CACHE']])

    # fetch upstream sources
    #
    # (some cygclasses always check their prerequisites, so this must be after
    # they are installed)
    logging.info('fetching source')
    subprocess.check_call(['cygport', package.script, 'download'])

    # do the build
    logging.info('building')
    subprocess.check_call([os.path.join(mydir, 'build.sh'), package.script])

    # publish contents of dist as artifacts
    dist = glob.glob(os.path.join('*', 'dist'))
    if dist:
        logging.info('publishing artifacts')
        shutil.move(dist[0], os.path.join(mydir, 'staging'))
